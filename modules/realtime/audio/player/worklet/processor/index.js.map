{
  "version": 3,
  "sources": ["source/index.ts"],
  "sourcesContent": ["interface IWrite {\n\tbuffer: Float32Array;\n\ttrackId: number;\n}\n\nclass StreamProcessor extends AudioWorkletProcessor {\n\t#started = false;\n\t#interrupted = false;\n\t#bufferLength = 128;\n\t#write: IWrite = { buffer: new Float32Array(this.#bufferLength), trackId: null };\n\t#writeOffset = 0;\n\t#outputBuffers: IWrite[] = [];\n\t#trackSampleOffsets: Record<string, number> = {};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.port.onmessage = this.#request.bind(this);\n\t}\n\n\t#writeData(float32Array: Float32Array, trackId: number = null) {\n\t\tlet { buffer } = this.#write;\n\t\tlet offset = this.#writeOffset;\n\t\tfor (let i = 0; i < float32Array.length; i++) {\n\t\t\tbuffer[offset++] = float32Array[i];\n\t\t\tif (offset >= buffer.length) {\n\t\t\t\tthis.#outputBuffers.push(this.#write);\n\t\t\t\tthis.#write = { buffer: new Float32Array(this.#bufferLength), trackId };\n\t\t\t\tbuffer = this.#write.buffer;\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tthis.#writeOffset = offset;\n\t\treturn true;\n\t}\n\n\tprocess(inputs: Float32Array[][], outputs: Float32Array[][]) {\n\t\tconst output = outputs[0];\n\t\tconst outputChannelData = output[0];\n\t\tconst outputBuffers = this.#outputBuffers;\n\n\t\tif (this.#interrupted) {\n\t\t\tthis.port.postMessage({ method: 'stop' });\n\t\t\treturn false;\n\t\t} else if (outputBuffers.length) {\n\t\t\t/**\n\t\t\t * If there are buffers in outputBuffers, start writing from the first buffer in the queue\n\t\t\t * to the output channel data.\n\t\t\t */\n\t\t\tthis.#started = true;\n\t\t\tconst { buffer, trackId } = outputBuffers.shift();\n\t\t\tfor (let i = 0; i < outputChannelData.length; i++) {\n\t\t\t\toutputChannelData[i] = buffer[i] || 0;\n\t\t\t}\n\t\t\tif (trackId) {\n\t\t\t\tthis.#trackSampleOffsets[trackId] = this.#trackSampleOffsets[trackId] || 0;\n\t\t\t\tthis.#trackSampleOffsets[trackId] += buffer.length;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (this.#started) {\n\t\t\t/**\n\t\t\t * If there is no buffered data and processing had previously started (#started),\n\t\t\t * send a \"stop\" message and returns false to end processing.\n\t\t\t */\n\t\t\tthis.port.postMessage({ method: 'stop' });\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t#request(event: MessageEvent) {\n\t\tif (!event.data?.method) return;\n\t\tconst { id, method } = event.data;\n\n\t\tlet data: any, trackId: number;\n\t\tswitch (method) {\n\t\t\tcase 'write':\n\t\t\t\tconst { buffer } = event.data.data;\n\t\t\t\ttrackId = event.data.data.trackId;\n\t\t\t\tconst float32Array = new Float32Array(buffer.length);\n\n\t\t\t\t// Convert Int16 to Float32\n\t\t\t\tbuffer.forEach((data: number, index: number) => (float32Array[index] = data / 0x8000));\n\t\t\t\tthis.#writeData(float32Array, trackId);\n\t\t\t\tbreak;\n\t\t\tcase 'offset':\n\t\t\tcase 'interrupt':\n\t\t\t\ttrackId = this.#write.trackId;\n\t\t\t\tconst offset = this.#trackSampleOffsets[trackId] || 0;\n\n\t\t\t\tmethod === 'interrupt' && (this.#interrupted = true);\n\n\t\t\t\tdata = { trackId, offset };\n\t\t\t\tbreak;\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Method \"\\${method}\" is invalid`);\n\t\t\t}\n\t\t}\n\n\t\t// Always send back a response\n\t\tthis.port.postMessage({ method: 'response', id, data });\n\t}\n}\n\nregisterProcessor('stream_processor', StreamProcessor);\n"],
  "mappings": "MAKA,IAAMA,EAAN,cAA8B,qBAAsB,CACnDC,GAAW,GACXC,GAAe,GACfC,GAAgB,IAChBC,GAAiB,CAAE,OAAQ,IAAI,aAAa,KAAKD,EAAa,EAAG,QAAS,IAAK,EAC/EE,GAAe,EACfC,GAA2B,CAAC,EAC5BC,GAA8C,CAAC,EAE/C,aAAc,CACb,MAAM,EACN,KAAK,KAAK,UAAY,KAAKC,GAAS,KAAK,IAAI,CAC9C,CAEAC,GAAWC,EAA4BC,EAAkB,KAAM,CAC9D,GAAI,CAAE,OAAAC,CAAO,EAAI,KAAKR,GAClBS,EAAS,KAAKR,GAClB,QAASS,EAAI,EAAGA,EAAIJ,EAAa,OAAQI,IACxCF,EAAOC,GAAQ,EAAIH,EAAaI,CAAC,EAC7BD,GAAUD,EAAO,SACpB,KAAKN,GAAe,KAAK,KAAKF,EAAM,EACpC,KAAKA,GAAS,CAAE,OAAQ,IAAI,aAAa,KAAKD,EAAa,EAAG,QAAAQ,CAAQ,EACtEC,EAAS,KAAKR,GAAO,OACrBS,EAAS,GAGX,YAAKR,GAAeQ,EACb,EACR,CAEA,QAAQE,EAA0BC,EAA2B,CAE5D,IAAMC,EADSD,EAAQ,CAAC,EACS,CAAC,EAC5BE,EAAgB,KAAKZ,GAE3B,GAAI,KAAKJ,GACR,YAAK,KAAK,YAAY,CAAE,OAAQ,MAAO,CAAC,EACjC,GACD,GAAIgB,EAAc,OAAQ,CAKhC,KAAKjB,GAAW,GAChB,GAAM,CAAE,OAAAW,EAAQ,QAAAD,CAAQ,EAAIO,EAAc,MAAM,EAChD,QAAS,EAAI,EAAG,EAAID,EAAkB,OAAQ,IAC7CA,EAAkB,CAAC,EAAIL,EAAO,CAAC,GAAK,EAErC,OAAID,IACH,KAAKJ,GAAoBI,CAAO,EAAI,KAAKJ,GAAoBI,CAAO,GAAK,EACzE,KAAKJ,GAAoBI,CAAO,GAAKC,EAAO,QAEtC,EACR,KAAO,QAAI,KAAKX,IAKf,KAAK,KAAK,YAAY,CAAE,OAAQ,MAAO,CAAC,EACjC,IAEA,EAET,CAEAO,GAASW,EAAqB,CAC7B,GAAI,CAACA,EAAM,MAAM,OAAQ,OACzB,GAAM,CAAE,GAAAC,EAAI,OAAAC,CAAO,EAAIF,EAAM,KAEzBG,EAAWX,EACf,OAAQU,EAAQ,CACf,IAAK,QACJ,GAAM,CAAE,OAAAT,CAAO,EAAIO,EAAM,KAAK,KAC9BR,EAAUQ,EAAM,KAAK,KAAK,QAC1B,IAAMT,EAAe,IAAI,aAAaE,EAAO,MAAM,EAGnDA,EAAO,QAAQ,CAACU,EAAcC,IAAmBb,EAAaa,CAAK,EAAID,EAAO,KAAO,EACrF,KAAKb,GAAWC,EAAcC,CAAO,EACrC,MACD,IAAK,SACL,IAAK,YACJA,EAAU,KAAKP,GAAO,QACtB,IAAMS,EAAS,KAAKN,GAAoBI,CAAO,GAAK,EAEpDU,IAAW,cAAgB,KAAKnB,GAAe,IAE/CoB,EAAO,CAAE,QAAAX,EAAS,OAAAE,CAAO,EACzB,MACD,QACC,MAAM,IAAI,MAAM,+BAAgC,CAElD,CAGA,KAAK,KAAK,YAAY,CAAE,OAAQ,WAAY,GAAAO,EAAI,KAAAE,CAAK,CAAC,CACvD,CACD,EAEA,kBAAkB,mBAAoBtB,CAAe",
  "names": ["StreamProcessor", "#started", "#interrupted", "#bufferLength", "#write", "#writeOffset", "#outputBuffers", "#trackSampleOffsets", "#request", "#writeData", "float32Array", "trackId", "buffer", "offset", "i", "inputs", "outputs", "outputChannelData", "outputBuffers", "event", "id", "method", "data", "index"]
}
