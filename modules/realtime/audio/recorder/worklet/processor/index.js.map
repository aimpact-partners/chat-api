{
  "version": 3,
  "sources": ["source/channels.ts", "source/utils.ts", "source/audio.ts", "source/index.ts"],
  "sourcesContent": ["export class Channels {\n\t/**\n\t * Reads and concatenates sampled chunks into separate audio channels.\n\t * This method reads and combines audio chunks based on the channels.\n\t * It can read a specific channel if specified or all channels up to maxChannels by default.\n\t * It returns the concatenated audio data for each channel in the form of Float32Array.\n\t *\n\t * @param chunks - An array of audio chunks, where each chunk contains arrays for each channel (e.g., [Left[], Right[]]).\n\t * @param channel - The specific channel to read. If -1, it reads all available channels up to `maxChannels`. Default is -1.\n\t * @param maxChannels - The maximum number of channels to read if `channel` is set to -1. Default is 9.\n\t *\n\t * @returns An array of concatenated `Float32Array`s, each representing the audio data for a specific channel.\n\t *\n\t * @throws Error If the specified channel index is out of range based on the available channels in the chunks.\n\t */\n\tstatic read(chunks: Float32Array[][], channel: number = -1, maxChannels: number = 9): Float32Array[] {\n\t\tlet channelLimit;\n\t\tif (channel !== -1) {\n\t\t\tif (chunks[0] && chunks[0].length - 1 < channel) {\n\t\t\t\tthrow new Error(`Channel \\${channel} out of range: max \\${chunks[0].length}`);\n\t\t\t}\n\t\t\tchannelLimit = channel + 1;\n\t\t} else {\n\t\t\tchannel = 0;\n\t\t\tchannelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\n\t\t}\n\n\t\tconst channels = [];\n\t\tfor (let n = channel; n < channelLimit; n++) {\n\t\t\tconst length = chunks.reduce((sum, chunk) => {\n\t\t\t\treturn sum + chunk[n].length;\n\t\t\t}, 0);\n\t\t\tconst buffers = chunks.map(chunk => chunk[n]);\n\t\t\tconst result = new Float32Array(length);\n\t\t\tlet offset = 0;\n\t\t\tfor (let i = 0; i < buffers.length; i++) {\n\t\t\t\tresult.set(buffers[i], offset);\n\t\t\t\toffset += buffers[i].length;\n\t\t\t}\n\t\t\tchannels[n] = result;\n\t\t}\n\t\treturn channels;\n\t}\n\n\t/**\n\t * Combines multiple audio channels into an interleaved format suitable for playback\n\t * and also calculates the mean values for a mono representation.\n\t *\n\t * @param channels - An array where each entry is a `Float32Array`\n\t * representing the audio data for a specific channel (e.g., [Left[], Right[]]).\n\t *\n\t * @returns An object containing:\n\t *   - `float32Array`: The interleaved audio data combining all channels\n\t *     (e.g., [L, R, L, R, ...] for stereo).\n\t *   - `meanValues`: A mono representation of the audio, where each value\n\t *     is the mean of all channels for that sample index.\n\t */\n\tstatic format(channels: Float32Array[]): { float32Array: Float32Array; meanValues: Float32Array } {\n\t\tif (channels.length === 1) {\n\t\t\t// Simple case is only one channel\n\t\t\tconst float32Array = channels[0].slice();\n\t\t\tconst meanValues = channels[0].slice();\n\t\t\treturn { float32Array, meanValues };\n\t\t} else {\n\t\t\tconst float32Array = new Float32Array(channels[0].length * channels.length);\n\t\t\tconst meanValues = new Float32Array(channels[0].length);\n\t\t\tfor (let i = 0; i < channels[0].length; i++) {\n\t\t\t\tconst offset = i * channels.length;\n\t\t\t\tlet meanValue = 0;\n\t\t\t\tfor (let n = 0; n < channels.length; n++) {\n\t\t\t\t\tfloat32Array[offset + n] = channels[n][i];\n\t\t\t\t\tmeanValue += channels[n][i];\n\t\t\t\t}\n\t\t\t\tmeanValues[i] = meanValue / channels.length;\n\t\t\t}\n\t\t\treturn { float32Array, meanValues };\n\t\t}\n\t}\n}\n", "export class Utils {\n\t/**\n\t * Converts 32-bit float data to 16-bit integers\n\t */\n\tstatic floatTo16BitPCM(float32Array: Float32Array): ArrayBuffer {\n\t\tconst buffer = new ArrayBuffer(float32Array.length * 2);\n\t\tconst view = new DataView(buffer);\n\t\tlet offset = 0;\n\t\tfor (let i = 0; i < float32Array.length; i++, offset += 2) {\n\t\t\tlet s = Math.max(-1, Math.min(1, float32Array[i]));\n\t\t\tview.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n\t\t}\n\t\treturn buffer;\n\t}\n}\n", "import { Channels } from './channels';\nimport { Utils } from './utils';\n\nexport class Audio {\n\t#found = false;\n\tget found() {\n\t\treturn this.#found;\n\t}\n\n\t#recording = false;\n\tget recording() {\n\t\treturn this.#recording;\n\t}\n\tset recording(value) {\n\t\tthis.#recording = value;\n\t}\n\n\t#chunks: Float32Array[][] = [];\n\tget chunks() {\n\t\treturn this.#chunks;\n\t}\n\n\t#port: MessagePort;\n\tconstructor(port: MessagePort) {\n\t\tthis.#port = port;\n\t}\n\n\treset() {\n\t\tthis.#chunks = [];\n\t\tthis.#recording = false;\n\t\tthis.#found = false;\n\t}\n\n\t/**\n\t * Retrieves the most recent amplitude values from the audio stream\n\t * @param {number} channel\n\t */\n\tget(channel: number = -1) {\n\t\tconst channels = Channels.read(this.chunks, channel);\n\t\tconst { meanValues } = Channels.format(channels);\n\t\treturn { meanValues, channels };\n\t}\n\n\t/**\n\t * Exports chunks as an audio/wav file\n\t */\n\texport() {\n\t\tconst channels = Channels.read(this.chunks);\n\t\tconst { float32Array, meanValues } = Channels.format(channels);\n\t\tconst data = Utils.floatTo16BitPCM(float32Array);\n\t\treturn { meanValues, audio: { bitsPerSample: 16, channels, data } };\n\t}\n\n\tprocess(inputs: Float32Array[][], outputs: Float32Array[][], parameters: any): boolean {\n\t\t// Copy input to output (e.g. speakers)\n\t\t// Note that this creates choppy sounds with Mac products\n\t\tconst sourceLimit = Math.min(inputs.length, outputs.length);\n\t\tfor (let index = 0; index < sourceLimit; index++) {\n\t\t\tconst input = inputs[index];\n\t\t\tconst output = outputs[index];\n\n\t\t\tconst channelCount = Math.min(input.length, output.length);\n\t\t\tfor (let channelIndex = 0; channelIndex < channelCount; channelIndex++) {\n\t\t\t\tinput[channelIndex].forEach((sample, i) => (output[channelIndex][i] = sample));\n\t\t\t}\n\t\t}\n\n\t\t// There's latency at the beginning of a stream before recording starts\n\t\t// Make sure we actually receive audio data before we start storing chunks\n\t\tlet slice = 0;\n\t\tif (!this.#found) {\n\t\t\tfor (const channel of inputs[0]) {\n\t\t\t\tslice = 0; // reset for each channel\n\t\t\t\tif (this.#found) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (channel) {\n\t\t\t\t\tfor (const value of channel) {\n\t\t\t\t\t\tif (value !== 0) {\n\t\t\t\t\t\t\t// Find only one non-zero entry in any channel\n\t\t\t\t\t\t\tthis.#found = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tslice++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (inputs[0] && inputs[0][0] && this.#found && this.#recording) {\n\t\t\t// We need to copy the TypedArray, because the `process` internals will reuse the same buffer to hold each input\n\t\t\tconst chunk = inputs[0].map(input => input.slice(slice));\n\t\t\tthis.#chunks.push(chunk);\n\t\t\tthis.#send(chunk);\n\t\t}\n\t\treturn true;\n\t}\n\n\t#send(chunk: Float32Array[]) {\n\t\tconst channels = Channels.read([chunk]);\n\t\tconst { float32Array, meanValues } = Channels.format(channels);\n\n\t\tconst rawAudioData = Utils.floatTo16BitPCM(float32Array);\n\t\tconst monoAudioData = Utils.floatTo16BitPCM(meanValues);\n\t\tthis.#port.postMessage({ method: 'chunk', data: { mono: monoAudioData, raw: rawAudioData } });\n\t}\n}\n", "import { Audio } from './audio';\n\nclass AudioProcessor extends AudioWorkletProcessor {\n\t#audio: Audio;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.port.onmessage = this.#request.bind(this);\n\t\tthis.#audio = new Audio(this.port);\n\t}\n\n\t#request(e: MessageEvent) {\n\t\tconst { method, id } = e.data;\n\n\t\tlet data: any;\n\t\tswitch (method) {\n\t\t\tcase 'record':\n\t\t\t\tthis.#audio.recording = true;\n\t\t\t\tbreak;\n\t\t\tcase 'stop':\n\t\t\t\tthis.#audio.recording = false;\n\t\t\t\tbreak;\n\t\t\tcase 'clear':\n\t\t\t\tthis.#audio.reset();\n\t\t\t\tbreak;\n\t\t\tcase 'export':\n\t\t\t\tdata = this.#audio.export();\n\t\t\t\tbreak;\n\t\t\tcase 'read':\n\t\t\t\tdata = this.#audio.get();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Always send back a response\n\t\tthis.port.postMessage({ method: 'response', id, data });\n\t}\n\n\tprocess(inputs: Float32Array[][], outputs: Float32Array[][], parameters: any): boolean {\n\t\treturn this.#audio.process(inputs, outputs, parameters);\n\t}\n}\n\nregisterProcessor('recorder_processor', AudioProcessor);\n"],
  "mappings": "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",
  "names": ["Channels", "chunks", "channel", "maxChannels", "channelLimit", "channels", "n", "length", "sum", "chunk", "buffers", "result", "offset", "i", "float32Array", "meanValues", "meanValue", "Utils", "float32Array", "buffer", "view", "offset", "i", "s", "Audio", "#found", "#recording", "value", "#chunks", "#port", "port", "channel", "channels", "Channels", "meanValues", "float32Array", "data", "Utils", "inputs", "outputs", "parameters", "sourceLimit", "index", "input", "output", "channelCount", "channelIndex", "sample", "i", "slice", "chunk", "#send", "rawAudioData", "monoAudioData", "AudioProcessor", "#audio", "#request", "Audio", "e", "method", "id", "data", "inputs", "outputs", "parameters"]
}
