(()=>{var i=class{static read(t,e=-1,a=9){let o;if(e!==-1){if(t[0]&&t[0].length-1<e)throw new Error("Channel ${channel} out of range: max ${chunks[0].length}");o=e+1}else e=0,o=Math.min(t[0]?t[0].length:1,a);let s=[];for(let r=e;r<o;r++){let n=t.reduce((l,d)=>l+d[r].length,0),f=t.map(l=>l[r]),u=new Float32Array(n),c=0;for(let l=0;l<f.length;l++)u.set(f[l],c),c+=f[l].length;s[r]=u}return s}static format(t){if(t.length===1){let e=t[0].slice(),a=t[0].slice();return{float32Array:e,meanValues:a}}else{let e=new Float32Array(t[0].length*t.length),a=new Float32Array(t[0].length);for(let o=0;o<t[0].length;o++){let s=o*t.length,r=0;for(let n=0;n<t.length;n++)e[s+n]=t[n][o],r+=t[n][o];a[o]=r/t.length}return{float32Array:e,meanValues:a}}}};var h=class{static floatTo16BitPCM(t){let e=new ArrayBuffer(t.length*2),a=new DataView(e),o=0;for(let s=0;s<t.length;s++,o+=2){let r=Math.max(-1,Math.min(1,t[s]));a.setInt16(o,r<0?r*32768:r*32767,!0)}return e}};var g=class{#t=!1;get found(){return this.#t}#e=!1;get recording(){return this.#e}set recording(t){this.#e=t}#r=[];get chunks(){return this.#r}#o;constructor(t){this.#o=t}reset(){this.#r=[],this.#e=!1,this.#t=!1}get(t=-1){let e=i.read(this.chunks,t),{meanValues:a}=i.format(e);return{meanValues:a,channels:e}}export(){let t=i.read(this.chunks),{float32Array:e,meanValues:a}=i.format(t),o=h.floatTo16BitPCM(e);return{meanValues:a,audio:{bitsPerSample:16,channels:t,data:o}}}process(t,e,a){let o=Math.min(t.length,e.length);for(let r=0;r<o;r++){let n=t[r],f=e[r],u=Math.min(n.length,f.length);for(let c=0;c<u;c++)n[c].forEach((l,d)=>f[c][d]=l)}let s=0;if(!this.#t)for(let r of t[0]){if(s=0,this.#t)break;if(r)for(let n of r)if(n!==0){this.#t=!0;break}else s++}if(t[0]&&t[0][0]&&this.#t&&this.#e){let r=t[0].map(n=>n.slice(s));this.#r.push(r),this.#a(r)}return!0}#a(t){let e=i.read([t]),{float32Array:a,meanValues:o}=i.format(e),s=h.floatTo16BitPCM(a),r=h.floatTo16BitPCM(o);this.#o.postMessage({method:"chunk",data:{mono:r,raw:s}})}};var p=class extends AudioWorkletProcessor{#t;constructor(){super(),this.port.onmessage=this.#e.bind(this),this.#t=new g(this.port)}#e(t){let{method:e,id:a}=t.data,o;switch(e){case"record":this.#t.recording=!0;break;case"stop":this.#t.recording=!1;break;case"clear":this.#t.reset();break;case"export":o=this.#t.export();break;case"read":o=this.#t.get();break;default:break}this.port.postMessage({method:"response",id:a,data:o})}process(t,e,a){return this.#t.process(t,e,a)}};registerProcessor("recorder_processor",p);})();
//# sourceMappingURL=index.js.map
