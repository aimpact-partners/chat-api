/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@aimpact/chat-api/data/interfaces';
import * as __beyond_dep_ns_1 from 'firebase-admin';
import * as __beyond_dep_ns_2 from '@aimpact/chat-api/business/response';
import * as __beyond_dep_ns_3 from '@aimpact/chat-api/business/errors';
// chat.ts
declare namespace ns_0 {
  import IChatData = __beyond_dep_ns_0.IChatData;
  import IMessageData = __beyond_dep_ns_0.IMessageData;
  import firestore = __beyond_dep_ns_1.firestore;
  import FirestoreService = ns_3.FirestoreService;
  import BusinessResponse = __beyond_dep_ns_2.BusinessResponse;
  export interface IChatParameters {
    id: string;
    name: string;
    metadata: {};
    parent?: string;
    children?: string;
    language: {
      default: string;
    };
    uid: string;
    projectId: string;
  }
  export class Chat {
    #private;
    private collection;
    private table;
    firestoreService: FirestoreService;
    constructor();
    static get(id: string, uid?: string, messages?: boolean): Promise<BusinessResponse<IChatData>>;
    static save(data: IChatParameters): Promise<BusinessResponse<unknown>>;
    /**
     *
     * @param id
     * @param message
     * @returns
     */
    static saveMessage(ChatId: string, params: IMessageData): Promise<{
      status: boolean;
      data: firestore.DocumentData;
      error?: undefined;
    } | {
      status: boolean;
      error: any;
      data?: undefined;
    }>;
    /**
     * sets the last interaction made in the Chat
     * assuming an interaction is the message/response pair
     * taking message(role:user)/response(role:system)
     * @param id
     * @param limit
     */
    static setLastInteractions(id: string, limit?: number): Promise<void>;
    /**
     * Functions migradas del objeto Chat inicial
     * @TODO validar funcionamiento
     */
    saveAll(items: IChatData[]): Promise<any[]>;
    delete(id: string): Promise<true | {
      status: boolean;
      error: string;
    }>;
    deleteAll(field: any, values: any): Promise<any>;
    validate(item: any): boolean;
  }
}


// chats.ts
declare namespace ns_1 {
  import BusinessResponse = __beyond_dep_ns_2.BusinessResponse;
  export class Chats {
    static byUser(id: string): Promise<__beyond_dep_ns_3.ns_1.BusinessErrorManager | BusinessResponse<unknown>>;
  }
}


// firestore\delete.ts
declare namespace ns_2 {
  export class BatchDeleter {
    private collectionRef;
    constructor(collectionRef: FirebaseFirestore.CollectionReference);
    deleteAll(property?: string, value?: any | any[]): Promise<any>;
  }
}


// firestore\service.ts
declare namespace ns_3 {
  export class FirestoreService {
    private collectionName;
    constructor(collectionName: string);
    getCollectionRef(): FirebaseFirestore.CollectionReference<FirebaseFirestore.DocumentData>;
    getDocumentRef(id: string): FirebaseFirestore.DocumentReference<FirebaseFirestore.DocumentData>;
  }
}


// message.ts
declare namespace ns_4 {
  import IMessageData = __beyond_dep_ns_0.IMessageData;
  export class Message {
    static publish(chatId: string, params: IMessageData): Promise<{
      status: boolean;
      data: FirebaseFirestore.DocumentData;
      error?: undefined;
    } | {
      status: boolean;
      error: any;
      data?: undefined;
    }>;
  }
}


// messages.ts
declare namespace ns_5 {
  export class Messages {
    static getByLimit(chatId: string, limit: number): Promise<FirebaseFirestore.DocumentData[]>;
  }
}


export import IChatParameters = ns_0.IChatParameters;
export import Chat = ns_0.Chat;
export import Chats = ns_1.Chats;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };